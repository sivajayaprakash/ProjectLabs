const WebSocket = require('ws');
const rtFeed = require('./event').rtFeed;

const utils = require('./utils');

let connection = null;
let disconnectConnection = false;
let hearbeatCheckerCalled = false;
let totalSymbolsAdded = 0;
let additionSub = false;
let additionSubLength = null;
let lastHeartBeatTime = 0;

let user;
let pwd;
let port;
let connectionUrl = 'wss://push.truedata.in:';
let bidaskData;
let heartbeatMessage;
let symbols = [];

const reconnectLogs = [];
const touchlineData = {};
const touchlineMap = {};

const { bidDeactivatedMessage, reconnectionTime } = utils;

module.exports.rtConnect = (
  username,
  password,
  allSymbols,
  userPort = 8082,
  bidaskFeed = 1,
  heartbeat = 1,
  replay = 0
) => {
  disconnectConnection = false;
  hearbeatCheckerCalled = false;
  if (typeof allSymbols === 'object') symbols = [...allSymbols];
  if (typeof allSymbols === 'string') symbols = [allSymbols];
  bidaskData = bidaskFeed === 1 ? true : false;
  heartbeatMessage = heartbeat === 1 ? true : false;
  if (replay === 1) connectionUrl = 'wss://replay.truedata.in:';
  user = username;
  pwd = password;
  port = userPort;
  connect();
};

module.exports.rtSubscribe = (subSymbols) => {
  if (connection) {
    additionSub = true;
    additionSubLength = subSymbols.length;
    symbols = [...symbols, ...subSymbols];
    subscribe(subSymbols);
  } else {
    console.log(
      'Error: Please use rtConnect(user, pwd, symbols, port, (bidask = 0), (heartbeat = 1)) to initate connection.'
    );
  }
};

module.exports.rtUnsubscribe = (unSubSymbols) => {
  symbols = symbols.filter((symbol) => !unSubSymbols.includes(symbol));
  unSubscribe(unSubSymbols);
};

module.exports.rtDisconnect = () => {
  disconnectConnection = true;
  for (let i = 0; i < 20; i++) {
    clearInterval(t);
  }
  closeConnection();
};

const connect = () => {
  console.log('Connecting..');
  url = connectionUrl + port + '?user=' + user + '&password=' + pwd;
  console.log(url);
  try {
    connection = new WebSocket(url);

    connection.onopen = socketonopen;
    connection.onerror = socketonerror;
    connection.onmessage = socketonmessage;
    connection.onclose = socketonclose;

    return true;
  } catch (error) {
    console.log(error);
    setInterval(connect, reconnectionTime);
    return false;
  }
};

function socketonopen(e) {
  console.log('Connected Websocket');
}
function socketonerror(e) {
  console.log('Websocket Error ' + e.message);
}

function socketonmessage(e) {
  var jsonObj = JSON.parse(e.data);
  if (jsonObj.success) {
    switch (jsonObj.message) {
      case 'TrueData Real Time Data Service':
        if (reconnectLogs.length === 0) console.log(jsonObj);

        subscribe(symbols);

        break;

      case 'symbols added':
        totalSymbolsAdded += jsonObj.symbolsadded;
        console.log(`Added Symbols:${jsonObj.symbolsadded}, Total Symbols Subscribed:${jsonObj.totalsymbolsubscribed}`);

        if (!hearbeatCheckerCalled) {
          hearbeatChecker();
          hearbeatCheckerCalled = true;
        }
        jsonObj.symbollist.forEach((d) => {
          touchlineData[d[1]] = handleTouchline(d);
          touchlineMap[d[1]] = d[0];
        });

        if (
          jsonObj.totalsymbolsubscribed === symbols.length ||
          (additionSub && totalSymbolsAdded === additionSubLength)
        ) {
          if (reconnectLogs.length === 0 || additionSub) rtFeed.emit('touchline', touchlineData);
          totalSymbolsAdded = 0;
          additionSub = false;
          additionSubLength = null;
        }

        break;
      case 'symbols removed':
        console.log(`Removed Symbols:${jsonObj.symbolsremoved}, Symbols Subscribed:${jsonObj.totalsymbolsubscribed}`);
        break;
      case 'touchline':
        jsonObj.symbollist.forEach((touchline) => {
          touchlineData[touchline[1]] = handleTouchline(touchline);
        });

        rtFeed.emit('touchline', touchlineData);

        break;

      case 'HeartBeat':
        heartbeatMessage && console.log('Message ' + jsonObj.message + ' Time: ' + jsonObj.timestamp);
        lastHeartBeatTime = Date.now();
        break;

      default:
        console.log(jsonObj);
    }
  }

  if (jsonObj.success == false) {
    console.log('Not connected');
    console.log(jsonObj);
  }

  if (jsonObj.trade != null) {
    const tradeArray = jsonObj.trade;
    rtFeed.emit('tick', handleRealTimeData(tradeArray));
  }

  if (jsonObj.bar1min || jsonObj.bar5min) {
    const barArray = jsonObj.bar1min || jsonObj.bar5min;
    rtFeed.emit('bar', handleBarData(barArray));
  }

  if (bidaskData && jsonObj.bidask != null) {
    const bidaskArray = jsonObj.bidask;
    rtFeed.emit('bidask', handleBidaskData(bidaskArray));
  }
}

function closeConnection() {
  connection.close();
}

function socketonclose() {
  console.log('Disconnected Websocket');
  if (!disconnectConnection) setTimeout(connect, reconnectionTime);
}

function subscribe(symbols) {
  //for-loop to override max 65000 characters issue
  for (let i = 0; i <= symbols.length; i += 1500) {
    const jsonRequest = {
      method: 'addsymbol',
      symbols: symbols.slice(i, i + 1500),
    };
    let s = JSON.stringify(jsonRequest);
    connection.send(s);
  }
}

function unSubscribe(symbols) {
  for (let i = 0; i <= symbols.length; i += 1500) {
    const jsonRequest = {
      method: 'removesymbol',
      symbols: symbols.slice(i, i + 1500),
    };
    let s = JSON.stringify(jsonRequest);
    connection.send(s);
  }
}

function hearbeatChecker() {
  t = setInterval(() => {
    const checkerHeartBeat = Date.now() - lastHeartBeatTime;
    if (checkerHeartBeat > 15000) {
      closeConnection();
      hearbeatCheckerCalled = false;
      const reconnectLog = `Auto Reconnect Initiated @ ${new Date().toLocaleTimeString()}`;
      reconnectLogs.push(reconnectLog);
      console.log(reconnectLogs);
      for (let i = 0; i < 20; i++) {
        clearInterval(t);
      }
    }
  }, 20000);
}

function handleTouchline(touchline) {
  return {
    Symbol: touchline[0],
    LastUpdateTime: touchline[2],
    LTP: +touchline[3],
    TickVolume: +touchline[4],
    ATP: +touchline[5],
    TotalVolume: +touchline[6],
    Open: +touchline[7],
    High: +touchline[8],
    Low: +touchline[9],
    Previous_Close: +touchline[10],
    Today_OI: +touchline[11],
    Previous_Open_Interest_Close: +touchline[12],
    Turnover: +touchline[13],
    Bid: +touchline[14] || 0,
    BidQty: +touchline[15] || 0,
    Ask: +touchline[16] || 0,
    AskQty: +touchline[17] || 0,
  };
}

function handleRealTimeData(tradeArray) {
  return {
    Symbol: touchlineMap[tradeArray[0]],
    Symbol_ID: +tradeArray[0],
    Timestamp: tradeArray[1],
    LTP: +tradeArray[2],
    LTQ: +tradeArray[3],
    ATP: +tradeArray[4],
    Volume: +tradeArray[5],
    Open: +tradeArray[6],
    High: +tradeArray[7],
    Low: +tradeArray[8],
    Prev_Close: +tradeArray[9],
    OI: +tradeArray[10],
    Prev_Open_Int_Close: +tradeArray[11],
    Day_Turnover: +tradeArray[12],
    Special: tradeArray[13],
    Tick_Sequence_No: +tradeArray[14],
    Bid: tradeArray[15] !== undefined ? +tradeArray[15] : bidDeactivatedMessage,
    Bid_Qty: tradeArray[16] !== undefined ? +tradeArray[16] : bidDeactivatedMessage,
    Ask: tradeArray[17] !== undefined ? +tradeArray[17] : bidDeactivatedMessage,
    Ask_Qty: tradeArray[18] !== undefined ? +tradeArray[18] : bidDeactivatedMessage,
  };
}

function handleBidaskData(bidaskArray) {
  return {
    Symbol: touchlineMap[bidaskArray[0]],
    SymbolId: bidaskArray[0],
    Time: bidaskArray[1],
    Bid: +bidaskArray[2],
    BidQty: +bidaskArray[3],
    Ask: +bidaskArray[4],
    AskQty: +bidaskArray[5],
  };
}

function handleBarData(barArray) {
  return {
    Symbol: touchlineMap[barArray[0]],
    SymbolId: barArray[0],
    Time: barArray[1],
    Open: +barArray[2],
    High: +barArray[3],
    Low: +barArray[4],
    Close: +barArray[5],
    Volume: +barArray[6],
    OI: +barArray[7],
  };
}
