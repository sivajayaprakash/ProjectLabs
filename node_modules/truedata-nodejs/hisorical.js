const axios = require('axios');
const fs = require('fs');
const csv = require('csvtojson');
const path = require('path');
const authEvent = require('./event').authEvent;

const utils = require('./utils');
const atPath = path.join(__dirname, 'at.json');

const segments = ['FO', 'EQ', 'NSEFUT', 'NSEEQ', 'NSEOPT', 'CDS', 'MCX'];

let user;
let pwd;
let grant_type = 'password';
let auth = true;
let initAuth = false;
const { root, login } = utils;
const routes = utils.routes;

let token = JSON.parse(fs.readFileSync(atPath));
if (Date.now() > token.time) auth = false;

module.exports.auth = async (username, password, force) => {
  initAuth = true;
  if ((!user && !username) || (!pwd && !password)) {
    console.log('Error: Please provide username and password');
    return;
  }
  user = username || user;
  pwd = password || pwd;

  if (!token || Date.now() > token.time || force) {
    const url = login;
    const params = new URLSearchParams();
    params.append('username', user);
    params.append('password', pwd);
    params.append('grant_type', grant_type);

    try {
      const res = await axios.post(url, params);
      time = Date.now() + (res.data.expires_in - 20) * 1000;
      token = { access_token: res.data.access_token, time };
      fs.writeFileSync(atPath, JSON.stringify(token));
      console.log('Authorization token has been upated');
      auth = true;
      authEvent.emit('resolve');
      setTimeout(() => {
        this.auth(user, pwd, true);
      }, Math.max(token.time - Date.now(), 100));

      return true;
    } catch (err) {
      let errorData=''
      if (err.response) errorData = err.response.data;
      console.log('Authentication Error ', errorData);
    }
  } else {
    setTimeout(() => {
      this.auth(user, pwd, true);
    }, Math.max(token.time - Date.now(), 100));
  }
};

module.exports.getTickData = (symbol, userFrom, userTo, userBidask, userResponse, getSymbolId) => {
  let from = userFrom;
  let to = userTo;
  let response = userResponse || 'json';
  let bidask = userBidask || 1;
  let symbolId = getSymbolId || 0;
  if (!userFrom & !userTo) {
    from = defaultTime('from');
    to = defaultTime('to');
  }
  if (userFrom && userFrom.length < 10) {
    const res = checkDuration(userFrom);
    from = res.from;
    to = res.to;
    bidask = userTo || bidask;
    response = userBidask || response;
    symbolId = userResponse || symbolId;
  }
  const url = `${root}${routes.getTickData}?symbol=${specialSymbol(
    symbol
  )}&bidask=${bidask}&from=${from}&to=${to}&response=csv`;
  return axioCall(url, symbol, response, symbolId);
};

module.exports.getBarData = (symbol, userFrom, userTo, userInterval, userResponse, getSymbolId) => {
  let from = userFrom;
  let to = userTo;
  let response = userResponse || 'json';
  let interval = userInterval || '1min';
  let symbolId = getSymbolId || 0;
  if (!userFrom & !userTo) {
    from = defaultTime('from');
    to = defaultTime('to');
  }
  if (userFrom && userFrom.length < 10) {
    const res = checkDuration(userFrom);
    from = res.from;
    to = res.to;
    interval = userTo || interval;
    response = userInterval || response;
    symbolId = userResponse || symbolId;
  }
  interval = interval.replace(/s|\s/g, '');
  const url = `${root}${routes.getBarData}?symbol=${specialSymbol(
    symbol
  )}&from=${from}&to=${to}&response=csv&interval=${interval}`;
  return axioCall(url, symbol, response, symbolId);
};

module.exports.getLastNBars = (symbol, nbars = 200, interval, response = 'json', getSymbolId = 0) => {
  interval = interval === 'EOD' ? 'EOD' : '1min';
  const url = `${root}${routes.getLastNBars}?symbol=${specialSymbol(
    symbol
  )}&response=csv&nbars=${nbars}&interval=${interval}&bidask=0`;
  return axioCall(url, symbol, response, getSymbolId);
};

module.exports.getLastNTicks = (symbol, nticks = 2000, bidask = 1, response = 'json', getSymbolId = 0) => {
  const url = `${root}${routes.getLastNTicks}?symbol=${specialSymbol(
    symbol
  )}&response=csv&nticks=${nticks}&interval=tick&bidask=${bidask}`;
  return axioCall(url, symbol, response, getSymbolId);
};

module.exports.getBhavCopy = (segment = 'FO', userDate, response = 'json') => {
  const date = userDate || bhavCopyDate();
  console.log(date);
  const url = `${root}${routes.getBhavCopy}?segment=${segment}&date=${date}&response=csv`;
  return axioCall(url, segment, response);
};

module.exports.getBhavCopyStatus = (segment = 'FO', response = 'json') => {
  const url = `${root}${routes.getBhavCopyStatus}?segment=${segment}&response=csv`;
  return axioCall(url, segment, response);
};

module.exports.getLTP = (symbol, bidask = 1, response = 'json', getSymbolId = 0) => {
  const url = `${root}${routes.getLastNTicks}?symbol=${specialSymbol(
    symbol
  )}&bidask=${bidask}&response=csv&nticks=1&interval=tick`;
  return axioCall(url, symbol, response, getSymbolId);
};

module.exports.getTopGainers = (segment = 'NSEFUT', top = 50, response = 'json') => {
  const url = `${root}${routes.getTopGainers}?segment=${segment}&response=csv&topn=${top}`;
  return axioCall(url, segment, response);
};

module.exports.getTopLosers = (segment = 'NSEFUT', top = 50, response = 'json') => {
  const url = `${root}${routes.getTopLosers}?segment=${segment}&response=csv&topn=${top}`;
  return axioCall(url, segment, response);
};

module.exports.getTopVolumeGainers = (segment = 'NSEFUT', top = 50, response = 'json') => {
  const url = `${root}${routes.getTopVolumeGainers}?segment=${segment}&response=csv&topn=${top}`;
  return axioCall(url, segment, response);
};

module.exports.getCorpAction = (symbol, response = 'json') => {
  const url = `${root}${routes.getCorpAction}?symbol=${specialSymbol(symbol)}&response=csv`;
  return axioCall(url, symbol, response);
};

module.exports.getSymbolNameChange = (response = 'json') => {
  const url = `${root}${routes.getSymbolNameChange}?response=csv&SYMBOL=`;
  return axioCall(url, null, response);
};

function checkDuration(customDuration) {
  const userDuration = customDuration.trim();
  const duration = userDuration.slice(-1).toUpperCase();
  let days = 1;
  if (duration === 'D') days = 1;
  else if (duration === 'W') days = 7;
  else if (duration === 'M') days = 30;
  else if (duration === 'Y') days = 365;
  let totalDays = +userDuration.trim().slice(0, -1) * days - 1;
  const date = new Date();
  const fromDate = new Date(date.getFullYear(), date.getMonth(), date.getDate() - totalDays, 9, 0, 0);
  return { from: defaultTime('from', fromDate), to: defaultTime('to') };
}

function bearer() {
  return {
    headers: {
      Authorization: `Bearer ${token.access_token}`,
    },
  };
}

async function axioCall(url, symbol, response, symbolId) {
  let config;
  let getSymbolId;
  if (symbolId === 1) {
    getSymbolId = axios
      .get(`https://api.truedata.in/getAllSymbols?segment=all&user=${user}&password=${pwd}&search=${symbol}`)
      .catch((err) => console.log(err.response.data.Mesage));
  }
  if (auth) config = bearer();
  else {
    if (!initAuth) console.log('Error: Please use " historical.auth(user, pwd) " for authentication"');
    await new Promise((resolve) => authEvent.on('resolve', resolve));
    config = bearer();
  }

  try {
    const res = await axios.get(url, config);
    const data = {};
    if (response === 'csv') return res.data;
    if (
      res.data.startsWith('No data exists') ||
      res.data.startsWith('Symbol does not exist') ||
      res.data.startsWith('Invalid parameter value')
    ) {
      data.Records = [];
      data.status = res.data;
      if (symbol) data.symbol = symbol;
      return data;
    }

    data.Records = await csv({
      colParser: {
        ltp: 'number',
        volume: 'number',
        oi: 'number',
        bid: 'number',
        bidqty: 'number',
        ask: 'number',
        askqty: 'number',
        open: 'number',
        high: 'number',
        low: 'number',
        close: 'number',
        vol: 'number',
        dopen: 'number',
        dhigh: 'number',
        dlow: 'number',
        dclose: 'number',
        turnover: 'number',
        pclose: 'number',
        change: 'number',
        changeper: 'number',
        symbolid: 'number',
      },
    }).fromString(res.data);
    data.status = 'Success';
    if (!segments.includes(symbol)) {
      data.symbol = symbol;
    } else {
      data.segment = symbol;
    }
    if (symbolId === 1) {
      try {
        const getSymbolIdRes = await Promise.all([getSymbolId]);
        data.symbolId = getSymbolIdRes[0].data.Records[0][0];
      } catch (err) {
        data.symbolId = null;
      }
    }
    return data;
  } catch (err) {
    const data = {};
    data.status = 'Something went wrong. Please check internet connection';
    if (err.response && err.response.data) data.status = err.response.data;
    if (symbol) data.symbol = symbol;
    throw data;
  }
}

function defaultTime(arg, argDate) {
  const date = argDate || new Date();
  if (arg === 'to')
    return `${date.getFullYear() - 2000}${utils.zeroChecker(date.getMonth() + 1)}${utils.zeroChecker(
      date.getDate()
    )}T23:59:00`;
  if (arg === 'from')
    return `${date.getFullYear() - 2000}${utils.zeroChecker(date.getMonth() + 1)}${utils.zeroChecker(
      date.getDate()
    )}T09:00:00`;
}

function bhavCopyDate() {
  const date = new Date();
  return `${date.getFullYear()}-${utils.zeroChecker(date.getMonth() + 1)}-${utils.zeroChecker(date.getDate())}`;
}

function specialSymbol(symbol) {
  return symbol.replace(/&/g, '%26');
}
